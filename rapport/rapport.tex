\documentclass[12pt]{article}
\usepackage[french]{varioref}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx} % Required for inserting images
\usepackage{float}
\usepackage{minted}
\title{Rapport projet de systéme}
\author{Leroy Florent et Salles Théo}
\date{Décembre 2023}
\begin{document}
\maketitle
\tableofcontents
\newpage
\section{File synchronisée}
La file synchronisée est construite comme une bibliothèque avec un fichier
interface \textit{file\_sync.h} et un fichier implémentions.
\textit{file\_sync.c}.
\subsection{file\_sync.h}
Le module est composé de 4 fonctions. Une fonction de création de la file
synchronisée, une qui libère les ressources allouées à la file et 2 autres
fonctions pour ajouter
ou retirer des éléments de cette file.
\subsection{file\_sync.c}
Toutes les informations de la file tel que les sémaphores, le buffer de données
et les
têtes de lecture
et d'écriture sont conservées dans un segment de mémoire partagé qui est créer
dans la fonction \textit{create\_file\_sync} avant l'initialisation des
sémaphores,
des têtes de lectures et du buffer.
Chaque action sur la file commence par l'ouverture du segment de mémoire
partagée
puis pour la fonction \textit{destroy\_file} on détruit toutes les sémaphores
puis on libère le segment de mémoire partagée. Pour les fonctions
\textit{defiler} et \textit{enfiler}
c'est un simple problème consommateur/producteur avec les sémaphores.
\section{Parseur}
Le module parseur est une réutilisation du module \textit{analyse} donner lors
du tp 2
avec des tests rajoutée notamment sur les malloc.
\section{Lanceur de commande}
Le nom des tubes est définis par une normes choisis qui s'applique
entre le lanceur et le client. Cette norme veut que le nom d'un tube soit une
chaîne de caractère qui
définit l'utilité du tube suivit du pid du client afin que chaque client
possède des tube qui lui sont propres.
\subsection{Macroconstante}
\begin{itemize}
      \item TUBE\_CLIENT\_: est le tube dans lequel le client écrit les
            informations
            pour le lanceur, il est crée par le client.
      \item TUBE\_RES\_CLIENT\_: est le tube dans lequel le resultat de la
            commande
            sera ecrit et envoyé au client, il est crée par le lanceur.
      \item TUBE\_ERR\_CLIENT\_: est le tube dans lequel une possible erreur
            lors
            de l'exécution de la commande sera écrit et envoyé au client, il
            est
            crée par le lanceur.
      \item BUF\_SIZE: Taille maximale en nombre de caractère des commandes
            avec
            leurs options.
      \item CMD\_SIZE: Taille maximale en nombre de  du nom de la commande
            (taille déterminer à partir du nombre de caractère de la plus
            grande
            commande
            linux avec une marge de sécurité).
      \item PID\_SIZE: Taille maximale en nombre de caractère du pid du client.
\end{itemize}
La structure \textit{my\_thread\_args} contient tous les arguments à
transmettre au thread.
\subsection{main}
Nous commençons par faire du lanceur un deamon. Puis on s'occupe de la gestion
du signal pour
terminer le lanceur.
Le principe du main est de créer un thread pour chaque demande d'exécution de
commande qui est représenter par le défilement du pid du client faisant la
demande d'exécution.
\subsection{run}
La fonction de lancement du thread ouvre les 3 tubes lui permettant de
communiquer
avec le client. Puis lit les informations donner par le client sur le tube
prévu
à cette effet. Ensuite on redirige les 2 sortie standard vers les 2 tubes
ouvert en écritures. On peut ensuite appeler la fonction \textit{parseur\_arg}
du module \textit{parseur} afin de récupérer la commande ainsi que chaque
option de celle-ci. On fini par utiliser la fonction \textit{execvp} afin
d'exécuter la commande demander.
\section{Client}
Le client récupère la commande à exécuter dans ses arguments lors de son
appelle.
On commence par générer le nom des tubes puis on créer ces tubes. Ensuite on
envoie
le pid du client dans la file afin que le lanceur puisse ouvrir les tubes.
Maintenant on ouvre le tube de communication entre le client et le lanceur
et on y écrit la commande à exécuter.
On peut ensuite ouvrir les tubes de communication entre le lanceur et le client
Puis en essaye de lire sur chaque tube et on l'affiche sur la sortie standard
\end{document}